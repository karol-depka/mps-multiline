package de.slisson.mps.editor.multiline.cells;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import java.util.concurrent.atomic.AtomicLong;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.nodeEditor.cells.ModelAccessor;
import jetbrains.mps.nodeEditor.EditorContext;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Indent;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
import org.apache.commons.lang.StringEscapeUtils;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class EditorCell_Multiline extends EditorCell_Collection {
  private static final AtomicLong CELL_ID_SEQUENCE = new AtomicLong();
  private static final Logger LOG = Logger.getLogger(EditorCell_Multiline.class);

  private ModelAccessor myModelAccessor;
  private MultilineText multilineText;

  protected EditorCell_Multiline(EditorContext context, ModelAccessor accessor, SNode node) {
    super(context, node, new CellLayout_Indent(), null);
    myModelAccessor = accessor;

    multilineText = new MultilineText(unescapeText(accessor.getText()));
    multilineText.addListener(MultilineText.PROPERTY_TEXT, new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent e) {
        String oldText = myModelAccessor.getText();
        String newText = ((String) e.getNewValue());
        if (neq_v798xa_a0c0a0a1a0e0a(oldText, newText)) {
          myModelAccessor.setText(escapeText(newText));
        }
      }
    });
    multilineText.addListener(MultilineText.PROPERTY_WORDS, new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent e) {
        modelToView();
      }
    });
    modelToView();
  }

  protected String escapeText(String text) {
    return StringEscapeUtils.escapeJava(text);
  }

  public String unescapeText(String text) {
    return StringEscapeUtils.unescapeJava(text);
  }

  @Override
  public void synchronizeViewWithModel() {
    multilineText.setTextSilently(unescapeText(myModelAccessor.getText()));
    modelToView();
  }

  protected void modelToView() {
    Iterable<String[]> lines = Sequence.fromArray(multilineText.getWords());
    setNumberOfLineCells(Sequence.fromIterable(lines).count());
    {
      Iterator<EditorCell_Line> lineCell_it = Sequence.fromIterable(getLineCells()).iterator();
      Iterator<String[]> words_it = Sequence.fromIterable(lines).iterator();
      EditorCell_Line lineCell_var;
      String[] words_var;
      while (lineCell_it.hasNext() && words_it.hasNext()) {
        lineCell_var = lineCell_it.next();
        words_var = words_it.next();
        lineCell_var.setWords(Sequence.fromArray(words_var));
      }
    }
  }

  public void setNumberOfLineCells(int count) {
    while (getCellsCount() > count) {
      removeCell(Sequence.fromIterable(Sequence.fromArray(getCells())).last());
    }
    while (getCellsCount() < count) {
      addEditorCell(newLineCell(getCellsCount()));
    }
    Sequence.fromIterable(getLineCells()).visitAll(new IVisitor<EditorCell_Line>() {
      public void visit(EditorCell_Line it) {
        it.setIndentLayoutNewLine(true);
      }
    });
    check_v798xa_a3a4(Sequence.fromIterable(getLineCells()).last(), this);
  }

  public int getCaretPosition() {
    int pos = 0;
    EditorCell selectedCell = getEditorContext().getSelectedCell();
    if (selectedCell instanceof EditorCell_Word) {
      EditorCell_Word selectedWordCell = (EditorCell_Word) selectedCell;
      String textBefore = getTextBefore(selectedWordCell, selectedWordCell.getCaretPosition());
      pos = textBefore.length();
    }

    return pos;
  }

  public void setCaretPosition(int pos) {
    int remainingPos = pos;
    for (EditorCell_Line lineCell : Sequence.fromIterable(getLineCells())) {
      int textLen = lineCell.getText().length();
      if (remainingPos <= textLen) {
        lineCell.setCaretPosition(getEditorContext(), remainingPos);
        break;
      }
      remainingPos -= textLen + 1;
    }
  }

  public String getTextBefore(EditorCell_Word wordCell, int pos) {
    StringBuffer textBefore = new StringBuffer();
    for (EditorCell_Line lineCell : Sequence.fromIterable(getLineCells())) {
      if (lineCell.containsCell(wordCell)) {
        Iterable<EditorCell_Word> cellsBefore = lineCell.getCellsBefore(wordCell);
        if (Sequence.fromIterable(cellsBefore).isNotEmpty()) {
          textBefore.append(IterableUtils.join(Sequence.fromIterable(cellsBefore).select(new ISelector<EditorCell_Word, String>() {
            public String select(EditorCell_Word it) {
              return it.getText();
            }
          }), " ")).append(" ");
        }
        textBefore.append(wordCell.getTextBefore(pos));
        break;
      } else {
        textBefore.append(lineCell.getText()).append("\n");
      }
    }

    return textBefore.toString();
  }

  public String getTextBeforeCaret() {
    return multilineText.getText().substring(0, getCaretPosition());
  }

  public String getTextAfterCaret() {
    return multilineText.getText().substring(getCaretPosition());
  }

  public Iterable<EditorCell_Line> getLineCells() {
    return Sequence.fromIterable(Sequence.fromArray(getCells())).select(new ISelector<EditorCell, EditorCell_Line>() {
      public EditorCell_Line select(EditorCell it) {
        return (EditorCell_Line) it;
      }
    });
  }

  public void setText(String newText) {
    newText = check_v798xa_a0a0l(newText);
    multilineText.setText(newText);
    modelToView();
  }

  private EditorCell_Line newLineCell(int lineNum) {
    EditorCell_Line lineCell = new EditorCell_Line(getEditorContext(), getSNode(), lineNum);
    lineCell.setCellId("Multiline_Line_" + CELL_ID_SEQUENCE.incrementAndGet());
    return lineCell;
  }

  public EditorCell_Word newWordCell(int lineNum, int wordNum) {
    EditorCell_Word wordCell = EditorCell_Word.create(getEditorContext(), new EditorCell_Multiline.WordModelAccessor(lineNum, wordNum, multilineText), getSNode());
    wordCell.setCellId("Multiline_Word_" + CELL_ID_SEQUENCE.incrementAndGet());
    return wordCell;
  }

  @Override
  public EditorCell_Line getCellAt(int i) {
    return (EditorCell_Line) super.getCellAt(i);
  }

  @Override
  public void addCellAt(int i, EditorCell cell, boolean b) {
    if (!(cell instanceof EditorCell_Line)) {
      throw new IllegalArgumentException("Cells of type EditorCell_Word allowed only. Was of type: " + check_v798xa_a0a0a0a0p(check_v798xa_a0a0a0a0a51(cell)));

    }
    super.addCellAt(i, cell, b);
  }

  public static EditorCell_Multiline create(EditorContext context, ModelAccessor accessor, SNode node) {
    EditorCell_Multiline result = new EditorCell_Multiline(context, accessor, node);
    return result;
  }

  private static void check_v798xa_a3a4(EditorCell_Line checkedDotOperand, EditorCell_Multiline checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      checkedDotOperand.setIndentLayoutNewLine(false);
    }

  }

  private static String check_v798xa_a0a0l(String checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.replace("\\n", "\n");
    }
    return null;
  }

  private static String check_v798xa_a0a0a0a0p(Class<?> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }

  private static Class<?> check_v798xa_a0a0a0a0a51(EditorCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getClass();
    }
    return null;
  }

  private static boolean neq_v798xa_a0c0a0a1a0e0a(Object a, Object b) {
    return !((a != null ?
      a.equals(b) :
      a == b
    ));
  }

  public class WordModelAccessor implements ModelAccessor {
    private int myLineNum;
    private int myWordNum;
    private MultilineText textSource;

    public WordModelAccessor(int lineNum, int wordNum, MultilineText textSource) {
      this.myLineNum = lineNum;
      this.myWordNum = wordNum;
      this.textSource = textSource;
    }

    public String getText() {
      return textSource.getWord(myLineNum, myWordNum);
    }

    public boolean isValidText(String text) {
      return true;
    }

    public void setText(String text) {
      textSource.setWord(myLineNum, myWordNum, text);
    }
  }
}
