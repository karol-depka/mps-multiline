package de.slisson.mps.editor.multiline.cells;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Property;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.nodeEditor.EditorContext;
import jetbrains.mps.nodeEditor.cells.ModelAccessor;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.nodeEditor.style.Style;
import jetbrains.mps.nodeEditor.CellActionType;
import jetbrains.mps.nodeEditor.EditorCellKeyMap;
import jetbrains.mps.nodeEditor.style.StyleAttributes;
import org.apache.commons.lang.StringEscapeUtils;
import jetbrains.mps.smodel.NodeReadAccessInEditorListener;
import jetbrains.mps.util.Pair;
import jetbrains.mps.smodel.NodeReadAccessCasterInEditor;
import jetbrains.mps.nodeEditor.cells.PropertyAccessor;

public class EditorCell_Word extends EditorCell_Property {
  private static final Logger LOG = Logger.getLogger(EditorCell_Word.class);

  public EditorCell_Word(EditorContext context, ModelAccessor modelAccessor, SNode node) {
    super(context, modelAccessor, node);
    setEditable(true);
    setDefaultText("");
    Style style = this.getStyle();
    setAction(CellActionType.INSERT, new NewLineAction(this));
    setAction(CellActionType.INSERT_BEFORE, new NewLineAction(this));
    setAction(CellActionType.SELECT_LEFT, new SelectLeftRightAction(true, this));
    setAction(CellActionType.SELECT_RIGHT, new SelectLeftRightAction(false, this));
    EditorCellKeyMap km = new EditorCellKeyMap();
    km.putAction("any", "VK_TAB", new TabAction(this));
    addKeyMap(km);
  }

  public void setIndentLayoutNewLine(boolean value) {
    getStyle().set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, value);
  }

  public void setNewLine(boolean newLine) {
    setIndentLayoutNewLine(newLine);
  }

  public boolean followedByNewLine() {
    Boolean result = getStyle().get(StyleAttributes.INDENT_LAYOUT_NEW_LINE);
    result = (result == null ?
      false :
      result
    );
    return result;
  }

  public String getTextIncludingSeparator() {
    return getText() + ((followedByNewLine() ?
      "\n" :
      " "
    ));
  }

  @Override
  public boolean canPasteText() {
    return isEditable();
  }

  @Override
  public void setText(String text) {
    super.setText(text);
  }

  @Override
  public boolean executeTextAction(CellActionType type, boolean allowErrors) {
    LOG.info("executeTextAction(" + type + ", " + allowErrors + ")");
    if (type == CellActionType.BACKSPACE) {
      if (getCaretPosition() == 0) {
        executeDeletePrecedingCharacter();
        return true;
      }
    } else if (type == CellActionType.DELETE) {
      if (getCaretPosition() == getText().length()) {
        executeDeleteFollowingCharacter();
        return true;
      }
    }
    return super.executeTextAction(type, allowErrors);
  }

  public void executeDeleteFollowingCharacter() {
    getEditorContext().executeCommand(new Runnable() {
      public void run() {
        deleteFollowingCharacter();
      }
    });
  }

  public void executeDeletePrecedingCharacter() {
    getEditorContext().executeCommand(new Runnable() {
      public void run() {
        deletePrecedingCharacter();
      }
    });
  }

  public void deleteFollowingCharacter() {
    LOG.info("Deleting following char");
    EditorCell_Multiline mlCell = this.getParent();
    if (mlCell != null) {
      int caretPos = mlCell.getCaretPosition();
      String text = mlCell.getTextAfterCaret();
      text = text.substring(1);
      text = mlCell.getTextBeforeCaret() + text;
      mlCell.setText(text);
      mlCell.setCaretPosition(caretPos);
    }
  }

  private void deletePrecedingCharacter() {
    LOG.info("Deleting preceding char");

    EditorCell_Multiline mlCell = this.getParent();
    if (mlCell != null) {
      int caretPos = mlCell.getCaretPosition();
      if (caretPos > 0) {
        String text = mlCell.getTextBeforeCaret();
        text = text.substring(0, text.length() - 1);
        text += mlCell.getTextAfterCaret();
        mlCell.setText(text);
        mlCell.setCaretPosition(caretPos - 1);
      }
    }
  }

  public void insertText(String text) {
    text = StringEscapeUtils.unescapeJava(text);
    EditorCell_Multiline mlCell = getParent();
    if (mlCell != null) {
      int newCaretPos = mlCell.getCaretPosition() + text.length();
      super.insertText(text);
      mlCell.setCaretPosition(newCaretPos);
    }
  }

  @Override
  public EditorCell_Multiline getParent() {
    return (EditorCell_Multiline) super.getParent();
  }

  @Override
  public void setCaretPositionIfPossible(int i) {
    LOG.info("setCaretPositionIfPossible(" + i + ") / text: \"" + getText() + "\"");
    if (i == getText().length() + 1) {
      int pos = getParent().getTextBefore(this, getText().length()).length() + 1;
      getParent().setCaretPosition(pos);
    } else {
      super.setCaretPositionIfPossible(i);
    }
  }

  public String getTextBefore(int pos) {
    String result = getText();
    result = result.substring(0, Math.min(pos, result.length()));
    return result;
  }

  @Override
  public String getRole() {
    // This is required for processing the INSERT action (the user presses ENTER). 
    // Otherwise the action is passed to the next children collection cell. 
    return "";
  }

  @Override
  public void synchronizeViewWithModel() {
    check_xru0dp_a0a61(getParent(), this);
  }

  private static void addPropertyDependenciesToEditor(NodeReadAccessInEditorListener listener, EditorCell_Word result) {
    for (Pair pair : listener.popCleanlyReadAccessedProperties()) {
      result.getEditor().addCellDependentOnNodeProperty(result, pair);
    }
  }

  public static EditorCell_Word create(EditorContext editorContext, ModelAccessor modelAccessor, SNode node) {
    NodeReadAccessInEditorListener listener = NodeReadAccessCasterInEditor.getReadAccessListener();
    if (modelAccessor instanceof PropertyAccessor) {
      if (listener != null) {
        listener.clearCleanlyReadAccessProperties();
      }
    }
    EditorCell_Word result = new EditorCell_Word(editorContext, modelAccessor, node);
    if (listener != null) {
      EditorCell_Word.addPropertyDependenciesToEditor(listener, result);
    }
    return result;
  }

  private static void check_xru0dp_a0a61(EditorCell_Multiline checkedDotOperand, EditorCell_Word checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      checkedDotOperand.synchronizeViewWithModel();
    }

  }
}
