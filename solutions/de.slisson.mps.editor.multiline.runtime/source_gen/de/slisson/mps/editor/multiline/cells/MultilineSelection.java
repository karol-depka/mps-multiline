package de.slisson.mps.editor.multiline.cells;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.selection.AbstractSelection;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.util.Map;
import jetbrains.mps.nodeEditor.cells.CellInfo;
import jetbrains.mps.nodeEditor.selection.SelectionStoreException;
import jetbrains.mps.nodeEditor.selection.SelectionRestoreException;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import jetbrains.mps.nodeEditor.selection.SelectionInfo;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.awt.Rectangle;
import jetbrains.mps.nodeEditor.CellActionType;
import de.slisson.mps.editor.multiline.runtime.ClipboardUtils;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.nodeEditor.selection.SelectionManager;
import jetbrains.mps.nodeEditor.selection.Selection;
import jetbrains.mps.nodeEditor.selection.SingularSelection;
import jetbrains.mps.nodeEditor.selection.EditorCellLabelSelection;
import java.util.List;
import java.util.Collections;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.project.structure.modules.ModuleReference;
import java.awt.Graphics2D;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import java.util.Stack;

public class MultilineSelection extends AbstractSelection {
  private static final Logger LOG = Logger.getLogger(MultilineSelection.class);
  private static final String PROPERTY_SELECTION_START = "selectionStart";
  private static final String PROPERTY_SELECTION_END = "selectionEnd";
  private static final String PROPERTY_LEFT_DIRECTION = "leftDirection";

  private EditorCell_Multiline myMultilineCell;
  private int mySelectionStart;
  private int mySelectionEnd;
  private boolean myLeftDirection;

  public MultilineSelection(EditorComponent editorComponent, Map<String, String> properties, CellInfo cellInfo) throws SelectionStoreException, SelectionRestoreException {
    super(editorComponent);
    if (cellInfo == null) {
      throw new SelectionStoreException("Required CellInfo parameter is null");
    }
    EditorCell editorCell = cellInfo.findCell(editorComponent);
    if (editorCell instanceof EditorCell_Multiline) {
      myMultilineCell = (EditorCell_Multiline) editorCell;
    } else {
      throw new SelectionRestoreException();
    }
    int start = SelectionInfo.Util.getIntProperty(properties, PROPERTY_SELECTION_START);
    int end = SelectionInfo.Util.getIntProperty(properties, PROPERTY_SELECTION_END);
    setSelectionRange(start, end);
    myLeftDirection = SelectionInfo.Util.getBooleanProperty(properties, PROPERTY_LEFT_DIRECTION);
  }

  public MultilineSelection(@NotNull EditorComponent editorComponent, @NotNull EditorCell_Multiline multilineCell, int start, int end, boolean left) {
    super(editorComponent);
    myMultilineCell = multilineCell;
    myLeftDirection = left;
    setSelectionRange(start, end);
  }

  public void setSelectionStart(int newValue) {
    setSelectionRange(newValue, mySelectionEnd);
  }

  public void setSelectionEnd(int newValue) {
    setSelectionRange(mySelectionStart, newValue);
  }

  public void setSelectionRange(int selStart, int selEnd) {
    mySelectionStart = selStart;
    mySelectionEnd = selEnd;
    updateVisibleSelection(selStart, selEnd);
  }

  public void updateVisibleSelection(int selStart, int selEnd) {
    int wordStart = 0;
    int caretPos = (myLeftDirection ?
      selStart :
      selEnd
    );
    for (EditorCell_Word wordCell : Sequence.fromIterable(myMultilineCell.getWordCells())) {
      int wordLength = wordCell.getText().length();
      int wordEnd = wordStart + wordLength;
      if (wordStart <= caretPos && caretPos <= wordEnd && selEnd != selStart) {
        wordCell.setCaretPosition(caretPos - wordStart);
      }
      wordCell.setSelectionStart(limitValue(selStart - wordStart, 0, wordLength));
      wordCell.setSelectionEnd(limitValue(selEnd - wordStart, 0, wordLength));
      wordStart += wordCell.getTextIncludingSeparator().length();
    }
  }

  public void activate() {
    updateVisibleSelection(mySelectionStart, mySelectionEnd);

    Rectangle firstBound = myMultilineCell.getWordCellContainingPos(mySelectionStart).getBounds();
    Rectangle lastBounds = myMultilineCell.getWordCellContainingPos(mySelectionStart).getBounds();
    getEditorComponent().scrollRectToVisible(firstBound.union(lastBounds));
    getEditorComponent().repaint();
  }

  public void deactivate() {
    updateVisibleSelection(0, 0);
  }

  public void ensureVisible() {
    EditorCell_Word firstSelectedWordCell = myMultilineCell.getWordCellContainingPos(mySelectionStart);
    if (firstSelectedWordCell != null) {
      firstSelectedWordCell.getEditor().scrollToCell(firstSelectedWordCell);
    }
  }

  public void executeAction(CellActionType type) {
    if (CellActionType.SELECT_LEFT == type || CellActionType.SELECT_RIGHT == type) {
      if ((myLeftDirection ?
        CellActionType.SELECT_LEFT == type :
        CellActionType.SELECT_RIGHT == type
      )) {
        enlargeSelection();
      } else {
        reduceSelection();
      }
    } else if (type == CellActionType.DELETE || type == CellActionType.BACKSPACE) {
      executeDeleteSelectedText();
    } else if (type == CellActionType.COPY) {
      String text = myMultilineCell.getText().substring(mySelectionStart, mySelectionEnd);
      ClipboardUtils.setClipboardText(text);
    } else if (type == CellActionType.CUT) {
      executeAction(CellActionType.COPY);
      executeDeleteSelectedText();
    } else if (type == CellActionType.PASTE) {
      getEditorComponent().getEditorContext().executeCommand(new Runnable() {
        public void run() {
          deleteSelectedText();
          String textToInsert = ClipboardUtils.getClipboardText();
          myMultilineCell.insertText(textToInsert);
        }
      });
    } else if (type == CellActionType.LEFT || type == CellActionType.RIGHT) {
      int caretPos = (type == CellActionType.LEFT ?
        mySelectionStart :
        mySelectionEnd
      );
      setSelectionRange(caretPos, caretPos);
      myMultilineCell.setCaretPosition(caretPos, true);
    } else {
      LOG.info("unhandled action: " + type);
    }

  }

  public void executeDeleteSelectedText() {
    if (ModelAccess.instance().canWrite()) {
      deleteSelectedText();
    } else {
      getEditorComponent().getEditorContext().executeCommand(new Runnable() {
        public void run() {
          deleteSelectedText();
        }
      });
    }
  }

  public void deleteSelectedText() {
    String text = myMultilineCell.getText();
    text = text.substring(0, mySelectionStart) + text.substring(mySelectionEnd, text.length());
    myMultilineCell.setText(text);
    int prevSelectionStart = mySelectionStart;
    setSelectionRange(0, 0);
    myMultilineCell.setCaretPosition(prevSelectionStart, true);
  }

  private void enlargeSelection() {
    int newSelectionStart = mySelectionStart;
    int newSelectionEnd = mySelectionEnd;
    if (myLeftDirection) {
      if (newSelectionStart > 0) {
        newSelectionStart--;
      }
    } else {
      int textLen = myMultilineCell.getText().length();
      if (newSelectionEnd < textLen - 1) {
        newSelectionEnd++;
      }
    }

    SelectionManager selectionManager = getEditorComponent().getSelectionManager();
    Selection newSelection;
    if (newSelectionStart != mySelectionStart || newSelectionEnd != mySelectionEnd) {
      newSelection = new MultilineSelection(getEditorComponent(), myMultilineCell, newSelectionStart, newSelectionEnd, myLeftDirection);
    } else {
      newSelection = selectionManager.createSelection(myMultilineCell.getParent());
      if (newSelection instanceof SingularSelection) {
        ((SingularSelection) newSelection).setSideSelectDirection((myLeftDirection ?
          SingularSelection.SideSelectDirection.LEFT :
          SingularSelection.SideSelectDirection.RIGHT
        ));
      }
    }
    selectionManager.pushSelection(newSelection);

    int caretPos = (myLeftDirection ?
      mySelectionStart :
      mySelectionEnd
    );
    EditorCell_Word selectedWord = myMultilineCell.getWordCellContainingPos(caretPos);
    if (selectedWord != null) {
      setDeepestSelection(new EditorCellLabelSelection(selectedWord), selectionManager);
    }
  }

  private void reduceSelection() {
    SelectionManager selectionManager = getEditorComponent().getSelectionManager();
    selectionManager.popSelection();
  }

  @NotNull
  public List<EditorCell> getSelectedCells() {
    return Collections.singletonList((EditorCell) myMultilineCell);
  }

  @NotNull
  public List<SNode> getSelectedNodes() {
    return Collections.singletonList(myMultilineCell.getSNode());
  }

  public SelectionInfo getSelectionInfo() throws SelectionStoreException {
    SelectionInfo selectionInfo = new SelectionInfo(this.getClass().getName(), ModuleReference.fromString("dc038ceb-b7ea-4fea-ac12-55f7400e97ba(de.slisson.mps.editor.multiline.runtime)").getModuleFqName());
    selectionInfo.setCellInfo(myMultilineCell.getCellInfo());
    selectionInfo.getPropertiesMap().put(PROPERTY_SELECTION_START, Integer.toString(mySelectionStart));
    selectionInfo.getPropertiesMap().put(PROPERTY_SELECTION_END, Integer.toString(mySelectionEnd));
    selectionInfo.getPropertiesMap().put(PROPERTY_LEFT_DIRECTION, Boolean.toString(myLeftDirection));
    return selectionInfo;
  }

  public boolean isSame(Selection other) {
    if (this == other) {
      return true;
    }
    if (other == null || getClass() != other.getClass()) {
      return false;
    }
    MultilineSelection otherSelection = (MultilineSelection) other;
    if (!(myMultilineCell.equals(otherSelection.myMultilineCell))) {
      return false;
    }
    if (mySelectionStart != otherSelection.mySelectionStart) {
      return false;
    }
    if (mySelectionEnd != otherSelection.mySelectionEnd) {
      return false;
    }
    if (myLeftDirection != otherSelection.myLeftDirection) {
      return false;
    }
    return true;
  }

  public void paintSelection(Graphics2D g) {
    /*
      for (EditorCell_Word wordCell : myMultilineCell.getWordCells()) {
        if (!(g.hitClip(wordCell.getX(), wordCell.getY(), wordCell.getWidth(), wordCell.getHeight()))) {
          continue;
        }
        wordCell.paint(g, ParentSettings.createDefaultSetting());
      }
    */
  }

  public int getCaretPosition() {
    return (myLeftDirection ?
      mySelectionStart :
      mySelectionEnd
    );
  }

  public EditorCell_Word getCellContainingCaret() {
    return myMultilineCell.getWordCellContainingPos(getCaretPosition());
  }

  public static int limitValue(int value, int min, int max) {
    int result = value;
    result = Math.min(result, max);
    result = Math.max(result, min);
    return result;
  }

  public static void setDeepestSelection(Selection newDeepest, SelectionManager manager) {
    try {
      Stack<SelectionInfo> selectionInfoStack = manager.getSelectionInfoStack();
      selectionInfoStack.set(0, newDeepest.getSelectionInfo());
      manager.setSelectionInfoStack(selectionInfoStack);
    } catch (SelectionStoreException ex) {
      LOG.error(ex);
    }
  }
}
